"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityProcessor = void 0;
const web3_js_1 = require("@solana/web3.js");
const axios_1 = __importDefault(require("axios"));
const bs58_1 = __importDefault(require("bs58"));
const base_1 = require("./base.cjs");
class EntityProcessor extends base_1.BaseProcessor {
    async request(method, entity, config) {
        const { appId, baseURL } = this.context;
        const { entityName, entityId } = entity;
        const { body, query, isAction } = config ?? {};
        const headers = this.buildHeaders(entityName, entityId);
        const url = entityId ? `/api/v1/${appId}/${entityName}/${entityId}` : `/api/v1/${appId}/${entityName}`;
        const { data: responseData, status } = await axios_1.default.request({
            baseURL,
            url,
            method,
            headers,
            data: body,
            params: query,
            validateStatus: () => true,
        });
        if ('message' in responseData) {
            throw new Error(responseData.message);
        }
        if (status >= 400) {
            throw new Error(`Request failed with status code ${status}`);
        }
        switch (responseData.type) {
            case 'action-sign': {
                if (isAction) {
                    throw new Error('Action already executed');
                }
                if (!this.context.signMessage) {
                    throw new Error('Sign message function not initialized');
                }
                const { message } = responseData.data;
                const buffer = new TextEncoder().encode(message);
                const result = await this.context.signMessage(buffer);
                if (!result) {
                    throw new Error('Sign message failed');
                }
                return this.request(method, entity, {
                    ...config,
                    body: { ...body, action: { sign: { signature: [...result] } } },
                    isAction: true,
                });
            }
            case 'action-transfer': {
                if (isAction) {
                    throw new Error('Action already executed');
                }
                if (!this.context.signTransaction) {
                    throw new Error('Sign transaction function not initialized');
                }
                const decodedBuffer = bs58_1.default.decode(responseData.data.serializedTransaction);
                const transaction = web3_js_1.Transaction.from(decodedBuffer);
                const signedTransaction = await this.context.signTransaction(transaction);
                const txBuffer = signedTransaction.serialize({
                    requireAllSignatures: false,
                    verifySignatures: false,
                });
                const serializedTransaction = bs58_1.default.encode(txBuffer);
                return this.request(method, entity, {
                    ...config,
                    body: { ...body, action: { transfer: { serializedTransaction } } },
                    isAction: true,
                });
            }
            default: {
                return responseData;
            }
        }
    }
}
exports.EntityProcessor = EntityProcessor;
