import { HTTP, isValidSolanaAddress, safeParseFloat } from "../utils/index.mjs";
export async function tryFetchDexscreenerToken(mint) {
    if (!isValidSolanaAddress(mint)) {
        throw new Error(`Invalid Solana address`);
    }
    try {
        return await fetchDexscreenerToken(mint);
    }
    catch {
        return null;
    }
}
async function fetchDexscreenerToken(mint) {
    const url = `https://api.dexscreener.com/latest/dex/tokens/${mint}`;
    const { data } = await HTTP.get(url);
    if (!data?.pairs || data.pairs.length === 0) {
        throw new Error(`No pairs found for token`);
    }
    const pair = data.pairs[0];
    let name = undefined;
    let symbol = undefined;
    for (const pair of data.pairs) {
        if (pair.baseToken.address === mint) {
            name = pair.baseToken.name;
            symbol = pair.baseToken.symbol;
            break;
        }
        else {
            if (pair.quoteToken.address === mint) {
                name = pair.quoteToken.name;
                symbol = pair.quoteToken.symbol;
                break;
            }
        }
    }
    if (!symbol) {
        throw new Error(`Token not found on dexscreener`);
    }
    return {
        contractAddress: mint,
        symbol,
        name,
        twitter: pair.info?.socials?.find(s => s.type?.toLowerCase() === 'twitter')?.url,
        telegram: pair.info?.socials?.find(s => s.type?.toLowerCase() === 'telegram')?.url,
        website: pair.info?.websites?.find(s => s.label?.toLowerCase() === 'website')?.url,
        image: pair.info?.imageUrl,
        marketcap: safeParseFloat(pair.marketCap),
        price: safeParseFloat(pair.priceUsd),
        buyTxIn24h: pair.txns?.h24?.buys,
        sellTxIn24h: pair.txns?.h24?.sells,
        volumeIn24h: pair.volume?.h24,
        priceChangeIn24h: pair.priceChange?.h24,
        liquidityInUSD: pair.liquidity?.usd,
    };
}
