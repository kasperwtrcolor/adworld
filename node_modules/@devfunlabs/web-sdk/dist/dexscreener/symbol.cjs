"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryFetchDexscreenerTokenBySymbol = tryFetchDexscreenerTokenBySymbol;
exports.fetchDexscreenerTokenBySymbol = fetchDexscreenerTokenBySymbol;
const utils_1 = require("../utils/index.cjs");
async function tryFetchDexscreenerTokenBySymbol(symbol) {
    try {
        return await fetchDexscreenerTokenBySymbol(symbol);
    }
    catch {
        return null;
    }
}
async function fetchDexscreenerTokenBySymbol(symbol) {
    const url = `https://api.dexscreener.com/latest/dex/search?q=${symbol}`;
    const { data } = await utils_1.HTTP.get(url);
    if (!data?.pairs || data.pairs.length === 0) {
        throw new Error(`No pairs found for token`);
    }
    const pair = data.pairs[0];
    if (!pair) {
        throw new Error(`No pairs found for token`);
    }
    const { baseToken, quoteToken } = pair;
    const token = pair.baseToken.symbol === symbol ? baseToken : quoteToken.symbol === symbol ? quoteToken : null;
    if (!token) {
        throw new Error(`Token not found on dexscreener`);
    }
    return {
        contractAddress: token.address,
        symbol: token.symbol,
        name: token.name,
        twitter: pair.info?.socials?.find(s => s.type?.toLowerCase() === 'twitter')?.url,
        telegram: pair.info?.socials?.find(s => s.type?.toLowerCase() === 'telegram')?.url,
        website: pair.info?.websites?.find(s => s.label?.toLowerCase() === 'website')?.url,
        image: pair.info?.imageUrl,
        marketcap: (0, utils_1.safeParseFloat)(pair.marketCap),
        price: (0, utils_1.safeParseFloat)(pair.priceUsd),
        buyTxIn24h: pair.txns?.h24?.buys,
        sellTxIn24h: pair.txns?.h24?.sells,
        volumeIn24h: pair.volume?.h24,
        priceChangeIn24h: pair.priceChange?.h24,
        liquidityInUSD: pair.liquidity?.usd,
    };
}
